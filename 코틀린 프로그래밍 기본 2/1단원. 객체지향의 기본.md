### 객체 지향 프로그래밍 (OOP)

- 프로그램의 구조를 객체 간 상호작용으로서 표현하는 프로그래밍 방식
- 절차적 프로그래밍의 한계를 극복하고자 나온 언어의 한 가지 방법론
- 객체와 관계를 표현하고 이를 통해 확장과 재사용에 용이

### 클래스란
- 분류, 계층, 등급 등의 우리말 뜻
- 특정 대상을 분류하고 특징(속성)과 동작 활동(함수) 내용을 기록

### 추상화
- 목표로 하는 것에 대해 필요한 만큼 속성과 동작을 정의하는 과정

### 생성자
- 클래스를 통해 객체가 만들어질 때 기본적으로 호출되는 함수
- 객체 생성 시 필요한 값을 인자로 설정할 수 있게 한다.
- 생성자를 위해 특별한 함수인 constructor()를 정의
```kotlin
class 클래스명 constructor(필요한 매개변수들..) { // 주 생성자의 위치
    ...
    constructor(필요한 매개변수들..) { // 부 생성자의 위치
        // 프로퍼티의 초기화
    }
}
```

### 상속
- 자식 클래스를 만들 때 상위 클래스(부모 클래스)의 속성과 기능을 물려받아 계승
- 상위(부모) 클래스의 프로퍼티와 메서드가 자식에 적용됨
- `open class` 사용 시 상속 가능
- 최상위 클래스는 `Any`이다.
```kotlin
open class 기반 클래스명 { // open 키워드로 파생 가능
    ...
}
class 파생 클래스명 : 기반 클래스명() {
    ...
}
```

## 다형성
> 같은 이름을 사용하지만 구현 내용이 다르거나 매개변수가 달라서 하나의 이름으로 다양한 기능을 수행할 수 있는 개념

### 오버라이딩
- 부모에서 사용되는 메서드를 자식에서도 같은 이름으로 사용하여 함수 내용을 재설계하는 방식
- 상위 클래스에서 오버라이딩 할 함수를 `open fun` 로 정의하고 하위 클래스에서는 `override fun` 로 정의한다.
- 파생 클래스에서 더 이상 오버라이딩을 금지할 때는 `final` 키워드를 추가한다.
```kotlin
val lark: Bird = Lark()
val parrot: Bird = Parrot()
lark.fly() // Lark 클래스 메서드를 호출
parrot.fly() // Parrot 클래스 메서드를 호출
```

### 오버로딩
- 메서드의 인자를 다르게하여 같은 이름, 다른 인자의 메서드를 정의하여 처리
- ex) `print(123)`, `print("Hello")` 인자는 다르지만 출력의 기능은 동일함
```kotlin
fun main() {
    val calc = Calc()
    println(calc.add(3,2))
    println(calc.add(3.2, 1.3))
}

class Calc {
    fun add(x: Int, y: Int) = x + y
    fun add(x: Double, y: Double) = x + y
}
```