# 5장. 컬렉션의 구조와 활용

### Collection
- 자주 사용되는 기초적인 자료구조를 모아놓은 일종의 프레임워크로 표준 라이브러리로 제공

### 코틀린의 컬렉션
- 종류: List, Set, Map 등이 있고 자바와 다르게 불변형과 가변형으로 나뉘어 컬렉션을 다룰 수 있다.
- 가장 상위의 인터페이스는 `Iterable` 이며, 컬렉션이 연속적인 요소를 표현할 수 있게 한다. (List, Set 해당)
- Map은 따로 인터페이스가 존재함.
- Mutable과 Immutable 따로 인터페이스가 존재.

### List
- 순서에 따라 정렬된 요소를 가지는 컬렉션
- 값을 변경할 수 없는 불변형 list를 만들기 위해 헬퍼함수인 `listOf()` 사용
- 가변형은 `mutableListOf()` 사용
- 인자는 가변 인자로 여러 개의 인자(vararg) 사용 가능.

### listOfNotNull()
- null을 제외한 요소만 반환

```kotlin
val nonNullsList: List<Int> = listOfNotNull(2, 3, 4, null, 5)
println(nonNullsList) // [2, 3, 4, 5]
```
### 추가 멤버 메서드
- get(i: Int)
- indexOf(e: E) : 첫 번째로 나타나는 인덱스 반환, 없으면 -1 반환
- subList(fromIndex: Int, toIndex: Int) : 특정 인덱스의 from과 to범위에 있는 요소 목록을 반환

## 가변형 List

### arrayListOf() 함수
- 가변형 헬퍼 함수를 사용하면 손쉽게 요소를 추가하거나 삭제할 수 있다.
- 반환 자료형: `ArrayList`

### mutableListOf() 함수
- MutableList 형으로 반환
- `toMutableList()` : 새로운 가변형 리스트 생성

### 리스트와 배열의 차이
- Array 클래스에 의해 생성되는 배열 객체는 내부 구조상 고정된 크기를 가짐
- 코틀린의 List<T>와 MutableList<T>는 인터페이스로 설계되어 있고 이것을 하위에서 특정한 자료구조로 구현
  - LinkedList<T>, ArrayList<T>
```kotlin
val list1: List<Int> = LinkedList<Int>()
val list2: List<Int> = ArrayList<Int>()
```
- Array<T>는 제네릭 관점에서 상/하위 자료형 관계가 성립하지 않는 **무변성**이다.
- List<T>는 **공변성**이기 때문에 하위인 List<Int>가 List<Number>에 지정될 수 있다.

## Set
- 정해진 순서가 없는 요소들의 집합
- 집합의 개념이기 때문에 동일한 요소를 중복해서 가질 수 없다.

### hashSetOf() 함수
- 해시 테이블에 요소를 저장할 수 있는 자바의 `HashSet` 컬렉션을 만든다.
- `HashSet`은 불변성 선언이 없기 때문에 추가 및 삭제 등의 기능을 수행할 수 있다.
- 입력 순서와 중복된 요소는 무시
- 검색 속도는 O(1)의 시간 복잡도를 가짐

### 해시 테이블
- 내부적으로 키와 인덱스를 이용해 검색과 변경 등을 매우 빠르게 처리할 수 있는 자료구조

### sortedSetOf() 함수
- 자바의 `TreeSet` 컬렉션을 정렬된 상태로 반환
- `java.util.*` 패키지를 임포트 해야 한다.
- TreeSet은 저장된 데이터의 값에 따라 정렬
  - 이진 탐색 트리인 RB 트리 알고리즘 사용
- HashSet보다는 성능이 떨어지고 데이터 추가 삭제 시 시간이 걸리지만, 검색과 정렬이 뛰어남

### 이진 탐색 트리와 RB 트리
- 이진 탐색 트리가 한쪽으로 치우친 트리 구조를 가지게 되는 경우 트리 높이만큼 시간이 걸리게 되는 최악의 경우 시간이 만들어 질 수 있다.
- RB 트리는 이 단점을 Red와 Black의 색상으로 치우친 결과 없이 구분되도록 하며, 최악의 경우에도 검색 등의 처리에서 일정 시간을 보장하는 자료구조

### linkedSetOf() 함수
- 링크드 리스트를 사용해 구현된 해시 테이블에 요소 저장
- HashSet, TreeSet보다 느리지만, 포인터 연결을 통해 메모리 저장 공간을 좀 더 효율적으로 사용

## Map
- 키와 값으로 구성된 요소를 저장
- 만약 동일한 키가 입력되면 대체됨

### mutableMapOf()
- put : 요소 추가
- remove : 요소 삭제

### 종류
- HashMap, SortedMap, LinkedMap