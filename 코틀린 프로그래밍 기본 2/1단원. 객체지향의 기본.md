# 1장. 클래스와 객체

### 객체 지향 프로그래밍 (OOP)

- 프로그램의 구조를 객체 간 상호작용으로서 표현하는 프로그래밍 방식
- 절차적 프로그래밍의 한계를 극복하고자 나온 언어의 한 가지 방법론
- 객체와 관계를 표현하고 이를 통해 확장과 재사용에 용이

### 클래스란
- 분류, 계층, 등급 등의 우리말 뜻
- 특정 대상을 분류하고 특징(속성)과 동작 활동(함수) 내용을 기록

### 추상화
- 목표로 하는 것에 대해 필요한 만큼 속성과 동작을 정의하는 과정

### 생성자
- 클래스를 통해 객체가 만들어질 때 기본적으로 호출되는 함수
- 객체 생성 시 필요한 값을 인자로 설정할 수 있게 한다.
- 생성자를 위해 특별한 함수인 constructor()를 정의
```kotlin
class 클래스명 constructor(필요한 매개변수들..) { // 주 생성자의 위치
    ...
    constructor(필요한 매개변수들..) { // 부 생성자의 위치
        // 프로퍼티의 초기화
    }
}
```

### 상속
- 자식 클래스를 만들 때 상위 클래스(부모 클래스)의 속성과 기능을 물려받아 계승
- 상위(부모) 클래스의 프로퍼티와 메서드가 자식에 적용됨
- `open class` 사용 시 상속 가능
- 최상위 클래스는 `Any`이다.
```kotlin
open class 기반 클래스명 { // open 키워드로 파생 가능
    ...
}
class 파생 클래스명 : 기반 클래스명() {
    ...
}
```

## 다형성
> 같은 이름을 사용하지만 구현 내용이 다르거나 매개변수가 달라서 하나의 이름으로 다양한 기능을 수행할 수 있는 개념

### 오버라이딩
- 부모에서 사용되는 메서드를 자식에서도 같은 이름으로 사용하여 함수 내용을 재설계하는 방식
- 상위 클래스에서 오버라이딩 할 함수를 `open fun` 로 정의하고 하위 클래스에서는 `override fun` 로 정의한다.
- 파생 클래스에서 더 이상 오버라이딩을 금지할 때는 `final` 키워드를 추가한다.
```kotlin
val lark: Bird = Lark()
val parrot: Bird = Parrot()
lark.fly() // Lark 클래스 메서드를 호출
parrot.fly() // Parrot 클래스 메서드를 호출
```

### 오버로딩
- 메서드의 인자를 다르게하여 같은 이름, 다른 인자의 메서드를 정의하여 처리
- ex) `print(123)`, `print("Hello")` 인자는 다르지만 출력의 기능은 동일함
```kotlin
fun main() {
    val calc = Calc()
    println(calc.add(3,2))
    println(calc.add(3.2, 1.3))
}

class Calc {
    fun add(x: Int, y: Int) = x + y
    fun add(x: Double, y: Double) = x + y
}
```

### super와 this
- 상위 클래스는 super 키워드로 현재 클래스는 this 키워드로 참조가 가능
- ex) `super.프로퍼티명` / `super.메서드명()` / `super()` : 생성자 참조

```kotlin
class Person(firstName: String, out: Unit = println("2")) {
    
    val fName = println("3")
    init {
        println("4")
    }
    
    constructor(firstName: String, age: Int,
                out: Unit = println("1")): this(firstName) {
                    println("5")
    }
    
    fun main() {
        val p1 = Person("Kildong", 30)
        
        // 1
        // 2
        // 3
        // 4
        // 5
    }
}
```

### 엣(@)
- 이너 클래스에서 바깥 클래스의 상위 클래스를 호출하려면 `super` 키워드와 함께 엣(@) 기호 옆에 바깥 클래스명을 작성해 호출

```kotlin
open class Base {
    ...
}

class Child : Base() {
    ...
    inner class Inside {
        fun test() {
            Child().f() // 바깥 클래스의 f() 메서드에 접근
            super@Child.f() // Child의 상위 클래스인 Base 클래스의 f() 메서드에 접근
        }
    }
}
```

### 앵글 브라켓을 사용한 이름 중복 해결

```kotlin
open class A {
    open fun f() = println("A Class f()")
}

interface B {
    fun f() = println("B Interface f()")
}

class C : A(), B { // 콤마(,)를 사용해 상속받을 클래스와 인터페이스 지정
    override fun f() = println("C class f()")
    fun test() {
        super<A>.f() // A 클래스의 f()
        super<B>.f() // B 클래스의 f()
    }
}
```

## 캡슐화
- 클래스를 작성할 때 외부에서 숨겨야 하는 속성이나 기능
- ex) 차를 타고 다닐 때 내부 엔진 동작 원리는 몰라도 운전할 수 있다.

### 가시성 지시자 (visibility modifiers)
- `private` : 외부 접근 x
- `public` : 외부 접근 o
- `protected` : 외부 접근 x, 하위 상속 요소 o (부모 자식 간에서는 접근이 가능하다.)
- `internal` : 같은 모듈 내부 접근 o (자바의 package 키워드)
- 최상위 함수에서는 private 클래스의 객체를 생성할 수 있음

### 선언 위치
- 전역 변수
- 함수
- 클래스

### 예시
```kotlin
open class Base {
    // 이 클래스에서는 a, b, c, d, e 접근 가능
    private val a = 1
    protected open val b = 2
    internal val c = 3
    val d = 4  // 가시성 지시자 기본값은 public

    protected class Nested {
        // 이 클래스에서는 a, b, c, d, e, f 접근 가능
        public val e: Int = 5 // public 생략 가능
        private val f: Int = 6
    }
}

class Derived : Base() {
    // 이 클래스에서는 b, c, d, e 접근 가능
    // a 는 접근 불가
    override val b = 5   // Base의 'b' 는 오버라이딩됨 - 상위와 같은 protected 지시자
}
class Other(base: Base) {
    // base.a, base.b는 접근 불가
    // base.c와 base.d는 접근 가능(같은 모듈 안에 있으므로)
    // Base.Nested는 접근 불가, Nested::e 역시 접근 불가
}
```

### 관계
- 연관(association)
- 의존(dependency)
- 집합(aggregation)
- 구성(composition)

## 프로퍼티와 초기화

### 게터와 세터의 구성
- 게터와 세터를 합쳐 접근 메서드라고함
- 자바에서는 모든 필드에 대한 접근 메서드를 만들어야 하는 수고를 해야함
- 코틀린에서는 접근 메서드가 내부적으로 생성됨

```kotlin
fun main() {
    val user = User(1, "Sean", 30)

    // 게터에 의한 값 획득
    val name = user.name

    // 세터에 의한 값 지정
    user.age = 41

    println("name: $name, ${user.age}")
}
```

### 게터와 세터가 포함되는 프로퍼티 선언 구조
- 불변형인 `val`은 게터만 설정 가능
```kotlin
val id: Int = _id
    get() = field
    set(value) {
        field = value
    }
```
- `value`: 세터의 매개변수로 외부로부터 값을 가져옴
  - 외부의 값을 받을 변수가 되므로 value 대신에 어떤 이름이든지 상관 없음
- `field`: 프로퍼티를 참조하는 변수로 보조 필드 (backing field)로 불림
  - 프로퍼티를 대신할 임시 필드로 만일 프로퍼티를 직접 사용하면 게터나 세터가 무한 호출되는 재귀에 빠짐

### 상속 구조
- `open val x -> override var x (O)`
- `open var x -> override val x (X)`

## 지연 초기화
- 변수나 객체의 값은 생성 시 초기화 필요
  - 클래스에서는 기본적으로 선언하는 프로퍼티 자료형들은 null을 가질 수 없음
  - 하지만, 객체의 정보가 나중에 나타나는 경우 나중에 초기화 할 수 있는 방법 필요
  - 지연 초기화를 위해 `lateinit`과 `lazy` 키워드 사용

### lateinit
- 의존성이 있는 초기화나 unit 테스트를 위한 코드를 작성 시
  - ex) Car클래스의 초기화 부분에 Engine 클래스와 의존성을 가지는 경우
  - Engine 객체가 생성되지 않으면 완전하게 초기화 할 수 없는 경우
  - ex) 단위 테스트를 위해 임시적으로 객체를 생성 시켜야 하는 경우
- 프로퍼티 지연 초기화
  - 클래스를 선언할 때 프로퍼티 선언은 null을 허용하지 않는다.
  - 하지만, 지연 초기화를 위한 lateinit 키워드를 사용하면 프로퍼티에 값이 바로 할당되지 않아도 됨
- `var` 로 선언된 프로퍼티만 가능
- 게터, 세터 사용 불가

```kotlin
class Person {
    lateinit var name: String // 1. 늦은 초기화를 위한 선언
    
    fun test() {
        if (!::name.isInitialized) { // 2. 프로퍼티의 초기화 여부 판단
            println("Not initialized")
        } else {
            println("Initialized")
        }
    }
}

fun main() {
    val jaemin = Person()
    jaemin.test()
    jaemin.name = "Jaemin" // 3. 이 시점에서 초기화됨 (지연 초기화)
    jaemin.test()
    println("name = ${jaemin.name}")
}

// Not initialized
// Initialized
// name = Jaemin
```
- 객체 또한 지연 초기화 가능
```kotlin
latinit var person: Person

fun main() {
    person = Person() // 생성자 호출 시점에서 초기화됨
}
```

### by lazy
- 호출 시점에 `by lazy {...}` 정의에 의해 블록 부분의 초기화를 진행한다.
- `val` 에서만 사용 가능

### 3가지 모드 지정 가능
- SYNCHRONIZED : 락을 사용해 단일 스레드만이 사용하는 것을 보장 (기본값)
- PUBLICATION : 여러 군데서 호출될 수 있으나 처음 초기화 된 후 반환 값을 사용
- NONE : 락을 사용하지 않기 때문에 빠르지만, 다중 스레드가 접근할 수 있음 (값의 일관성 보장 X)

```kotlin
private val model by lazy (mode = LazyThreadSafetyMode.NONE) {
    Injector().app().transactionsModel() // 이 코드는 단일 스레드의 사용이 보장될 때
}
```