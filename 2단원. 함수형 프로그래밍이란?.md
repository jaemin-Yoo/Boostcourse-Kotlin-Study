## 함수
```kotlin
fun sum(a: Int, b: Int): Int {
  var sum = a+b
  return sum
}
```
`fun` 키워드 사용

- 반환 값이 없는 경우는 `Unit`을 사용 (생략 가능) -> 자바의 `void`
```kotlin
fun sum(a: Int): Unit
```

- 간략화 가능
```kotlin
fun sum(a: Int, b: Int) = a + b
```

### 최상위 함수
- 클래스나 함수 안에 있는 함수가 아닌 제일 바깥에 있는 함수

### 지역 함수
- 함수 안에 함수를 정의하는 경우
- 지역 함수는 반드시 함수를 호출하기 전에 정의를 해줘야 한다.

### 가변 인자
- 인자의 개수가 정해진 경우가 아니라서 여러 개의 인자를 받을 수 있을 때 사용
```kotlin
fun sum(vararg n: Int): Int = n.sum()
```

> 매개 변수: 함수를 정의할 때 사용된 변수  
> 인자: 함수를 사용할 때 넣는 값

### Default
- 함수 매개변수에 기본 값을 할당할 수 있다.
```kotlin
fun sum(a: Int, b: Int = 5) = a + b

fun main(){
  sum(b = 2)
}
```

### 함수의 동작 원리
1. 진입점에 들어감
2. 함수 인자 확인
3. 함수 프레임 생성 (스택 영역)
  - 프레임 내 지역 변수, 상수 풀, 항(Operand) 등이 할당됨
  - 새로운 함수 호출 시 새로운 프레임 생성
4. 반환 되면 스택 메모리에서 `pop`됨


> 스택: 임시적으로 사용, 높은 주소 -> 낮은 주소  
> 힙: 동적 메모리 공간, 낮은 주소 -> 높은 주소

---

## 예제: 평균 구하기

목표: 하나 이상의 실수를 받아서 모든 실수의 합의 평균을 구하고 출력 하려고 합니다.

다음 조건을 만족하는 함수를 구현해 보세요!

- 초기값을 위한 인자는 Float형
- 초기값은 두번째 부터 나열된 인자의 최종 평균 결과에 더함
- 초기값에 아무런 인자를 입력하지 않으면 0을 기본 사용
- 두번째부터 받아들일 인자는 가변형 인자로 모두 실수형 Float
- 반환값은 모든 인자의 평균값으로 마찬가지로 실수형 Double

```kotlin
fun avgFunc(initial: ____(1)______, _____(2)_____ numbers: Float): Double {
    var result = 0f
    for (num in numbers) {
        ________(3)_________
    }
    println("result: $result, numbers.size: ${numbers.size}")
    val avg = __________(4)____________
    return ________(5)_________
}

fun main() {
    val result = avgFunc(5f, 100f, 90f, 80f)  // 첫번째 인자: 초기값, 이후 인자는 가변인자
    println("avg result: $result")
}
```

> (1) Float = 0f  
> (2) vararg  
> (3) result += num  
> (4) result / numbers.size  
> (5) (avg+initial).toDouble()

---

### 코틀린은 다중 패러다임 언어
- 함수형 프로그래밍
- 객체 지향 프로그래밍

### 함수형 프로그래밍
- 코드 간략, 테스트나 재사용성 증가(함수 단위로 테스트)
- 람다식, 고차 함수를 사용해 구성(함수를 반환)
- 순수 함수(함수를 인자로 사용)

### 순수 함수
- 사이드 이펙트(부작용)가 없는 함수
  - 동일한 인자에 동일한 결과 값 반환
  - 값이 예측 가능
- 순수 함수의 조건
  - 함수 외부의 어떤 상태도 바꾸지 않음
  - 동일한 인자에 동일한 결과 값 반환

EX) 순수 함수가 아닌 경우
```kotlin
fun check() {
  val test = User.grade() // 외부 User 객체를 사용함으로써 User 객체 안의 값에 따라 결과가 변함
  if (test != null) process(test)
}
```

### 순수 함수를 왜?
- 입력과 내용을 분리하고 모듈화 하므로 **재사용성**이 높아짐 (여러가지 함수와 조합해도 문제없음)
- 특정 상태에 영향을 주지 않으므로 병행 작업 시 안전
- 값 예측이 가능하기 떄문에 테스트, 디버깅에 유리

### 함수형 프로그래밍에 적용
- 함수를 매개변수, 인자, 반환 값에 적용 (고차 함수)
- 함수를 변수나 데이터 구조에 저장
- 유연성 증가

### 람다식
- 익명 함수 (이름이 없는 함수)
` { x, y -> x + y } `
- 고차 함수에서 인자로 넘기거나 결과값으로 반환 등을 할 수 있음

### 일급 객체
- 함수의 인자로 전달 가능
- 반환값에 사용 가능
- 변수에 담을 수 있음
- 코틀린에서 함수는 1급 객체로 다룸 (= 1급함수)

### 고차 함수
- 다른 함수를 인자로 사용
- 결과값으로 반환하는 함수
```kotlin
fun main() {
  println(highFunc({ x, y -> x + y }, 10, 20))
}

fun highFunc(sum: (Int, Int) -> Int, a: Int, b: Int): Int = sum(a, b)
```
